// ? 1.기술
// promise의 개념에 대해 설명하고, 콜백 함수 방식과 차이점을 설명

// 등장배경(ES2015)
// * 과거 자바스크립트는 비동기 처리를 위한 패턴으로 콜백함수를 사용했었는데, 이 패턴은 콜백헬로 인해 가독성안좋아질 수 있고,
// * 에러처리가 곤란하고, 여러 비동기 처리를 한번에 하기에도 한계가 있다.
// ? q. 콜백패턴에서 에러처리가 어떻게 곤란하다는거지? try catch문으로 예외처리를 할 순 없는건가?

try {
  setTimeout(function () {
    throw '에러가 발생했다!';
  }, 1000);
} catch (e) {
  console.log(e);
  console.log('에러에서 복구됐다.');
}

// (setTimeout으로 비동기처리를 재연함)
// 결국 비동기처리의 콜백은 동기적으로 처리되는 콜스택이 비워지고 나서야 타이머이벤트에 의해 발생하기때문에 해당 코드은 동작하지 않는다.

setTimeout(function () {
  try {
    //...
    throw '에러가 발생했다!';
    //...
  } catch (e) {
    console.log(e);
    console.log('에러에서 복구됐다.');
  }
}, 1000);

// 이 방법은 비슷한 에러를 통하해서 처리할 수 없다. 콜백을 정의할 때 마다 try-catch를 작성해야함.
// 물론 이것도 해결가능한 방법이 있다. 하지만 코드봤을 때 나는 이해가안됨. // * 바로아래코드
/**
 * 예외 처리를 분담하는 함수
 * try-catch를 공통화할 수 있다.
 */
function errorHandle(process) {
  return function () {
    try {
      return process.apply(this, arguments);
    } catch (e) {
      console.log(e);
      console.log('에러에서 복구됐다.');
    }
  };
}

// errorHandle()에 에러가 발생할지 모를 콜백을 전달한다.
setTimeout(
  errorHandle(function () {
    throw '에러가 발생했다!';
  }),
  1000
);

setTimeout(
  errorHandle(function () {
    throw '에러가 발생했다!';
  }),
  2000
);

//↑ 두 setTimeout에서 발생한 에러를 감지한다.

// * 결론만 보자면 try-catch를 잘 이용하더라도 코드가 복잡해지고, 가독성이 안좋아질 수 밖에 없다.

// ? 그래서 Promise란?
// 프로미스는 비동기 작업을 쉽게 처리할 수 있도록 정의된 객체이다.
// MDN의 설명을 빌리자면, 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있다.
// 하지만 비동기 메서드의 최종 결과를 반환하는 것은 아니고, 미래의 어떤 시점에 결과를 제공하겠다는 약속(promise)을 반환한다.
// 프로미스는 pending, fulfilled, rejects 이 세가지 상태를 가짐.

// 프로미스는 프로미스 생성자함수가 인자로 전달받은 콜백 내부에서 비동기 처리를 수행한다.
// 이때 인자로 받은 콜백 자체가 비동기로 처리되는것이 아니라 그 안에서 비동기 처리를 하게되면
// resolve나 reject에 특정결과를 줬을 때 프로미스객체의 값이 이행 또는 거절로 변화하게된다.

// 쉽게 생각하면 프로미스의 인자로 주는 콜백 자체는 동기적으로 작동함. (이때 프로미스객체는 대기상태)
// 그러나 그 후 프로미스의 상태가 이행 또는 거절로 변하면 then 또는 catch에 의해 then또는 catch에 전달된 콜백이 비동기로 처리된다.
// 그리고 또다른 프로미스를 반환함

// ? 이제 프로미스패턴과와 콜백패턴의 차이점
// 문제1. 콜백패턴을 이용해서 비동기 처리를 해본적이 없다. -> 콜백패턴에 대한 정보를 구글링했지만 이해가 잘 안되고 결정적으로 잘 와닿지가 않는다.
// -> 콜백패턴의 문제점이라고 할 대표적인 예시가 머리속에서 잘 연상되지않음.

// 해결책1. 그럼 콜백패턴을 바로 이해하려하기보단, 내가 프로미스패턴을 이용해서 했던것들을 만약, 프로미스가 없다면 어떤일이 벌어지는지를 생각해보자.
// -> 비동기 처리는 했는데 그 후 그 값을 어떻게 이용하지? -> 비동기함수 내부에 그 후 처리기(콜백)을 함께 준다면? 콜백을 통해 그 값으로 무언가를 할 수 있겠지.
//  -> 그럼 또 그 값을 이용해서 무언가를 해야한다면? -> 전설의 콜백 헬 피라미드가 되는게아닐까?
//  -> 아니면 비동기 안에서 또다른 비동기가 있다면? -> 이 상황은 정말로 머리속에 안그려진다.

// 이렇게 생각하면 프로미스패턴 또한 프로미스 헬을 만들 수 있다. 실제로 프로미스헬이란 표현도 있고 그래서 필요에 따라 await를 사용한다.
// 아무튼 콜백패턴의 느낌을 간접적이게나마 느낄 수 있다. 모든 동작을 콜백의 연속으로 처리해한다는 것.
// 확실히 프로미스패턴이 가독성이 정말 좋다. 동작의 흐름이 직관적이고 결과예측에도 더 편하다라고 생각함.
// -> then을 여러번 호출하면서 한번에 한가지 처리를 하게할 수 있음. (직관적, 가독성 up)
// 거기에 더해 then은 비동기로 처리되기때문에 한번의 then이 끝나야 다음 then의 처리가 시작한다는 보장을 받을 수 있다.(예측가능)
// 더군다나 에러헨들링도 정말편함. catch하나만 있으면 어디서 문제가 생겼는지도 확인할 수 있다.
// 위 쪽 코드를 보면알다싶히 콜백패턴에서 오류처리는 정말 복잡함.
// 그리고 여러 비동기처리를 한번에 처리하기도 용이함(Promise.all)

// ? 추가적인 학습
// 개발을 하면서 프로미스를 직접사용할 일이 거의 없었는데 막상 다시 설명하려고 하니 너무 헷갈렸다.
// 평소 axios를 통해 http통신을 구현하는데, axios또한 프로미스를 기반으로 하기 있기에 기본적인 동작이해를 더 깊이있게 학습해봐야겠다.

const condition = 'ok';
console.log('어디가 비동기로 처리될까? --- 1');

const promise = new Promise((resolve, reject) => {
  // 비동기처리를 재연하기 위한 setTimeOut
  console.log('어디가 비동기로 처리될까? --- 2');

  setTimeout(() => {
    console.log('어디가 비동기로 처리될까? --- 3');

    if (condition === 'ok') {
      resolve('성공적인 비동기처리');
    } else {
      reject('뭔가 잘못됨');
    }
  }, 1000);

  console.log('어디가 비동기로 처리될까? --- 4');
})
  .then((res) => {
    console.log('어디가 비동기로 처리될까? --- 5');
    console.log('비동기로 전달받은 결과값1 : ', res);
    return res + '  then에 의한 경유1';
  })
  .then((res) => {
    console.log('어디가 비동기로 처리될까? --- 6');
    console.log('비동기로 전달받은 결과값2 : ', res);
    return res + '  then에 의한 경유2';
  })
  .catch((err) => console.error(err));

console.log('어디가 비동기로 처리될까? --- 7');
console.log('현재 프로미스 객체: ', promise);

setTimeout(() => {
  console.log('미래의 프로미스 객체: ', promise);
}, 3000);

const func3 = (res) => {
  return res + ' step';
};
const func2 = (res) => {
  return func3(res + ' step');
};
const func1 = (res) => {
  return func2(res);
};

const condition = 'ok';
setTimeout(() => {
  try {
    if (condition === 'ok') {
      func1(condition);
    } else {
      throw new Error('뭔가 잘못된거같아!');
    }
  } catch (err) {
    console.error(err);
  }
}, 1000);
