안전, 멱등, 캐시가능

# 안전

1. 호출해도 리소스를 변경하지 않는다.(ex. GET)

- 호출이 많아 로그가 넘쳐 장애가 발생하는 경우가 생길 수 있는데, 여기서 '안전'의 의미는 단순히 해당 요청이 리소스의 값을 변경하는냐에만 초점을 맞춘다.

# 멱등(Idempotent)

1. f(f(x)) === f(x)

2. 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다.

3. 멱등 메서드

- GET: 한번 조회하든, 몇 번 조회하든 같은 결과가 조회된다.
- PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.
  - PUT의 경우, 해당 리소스가 없을 시 리소스를 생성한다. 그 뒤의 요청은 해당 URI의 리소스를 대체한다. => 여러번 호출해도 항상 결과가 같다.
- DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
  - DELETE는 멱등하므로 REST APT에서 개발자는 '목록의 마지막 항목 제거' 기능을 만들어서는 안된다.
- POST: 멱등이 아니다! 두번 호출하면 같은 결제가 중복해서 발생할 수 있다.

4. 활용

- 자동 복구 메커니즘
- 서버가 TIMEOUT 등으로 정상 응답을 못주었을때, 클라이언트가 같은 요청을 다시 해도 되는가? -판단근거
  - 예를 들어, 유저가 게시글을 삭제했는데, 서버에서 응답을 주지못하거나 응답시간이 너무 오래걸려 유저는 해당 게시글이 삭제됐는지 알 수 없다. 이때 게시글 삭제 버튼을 추가적으로 눌러도 해당게시글 DELETE는 멱등하기 때문에 문제되지않는다.

5. 재요청 중간에 다른 곳에서 리소스를 변경해버리는 경우

```
사용장1: GET -> username:A, age:20
사용자2: PUT -> username:A, age:30
사용자1: GET -> username:A, age:30 -> 사용자2의 영향으로 바뀐 데이터 조회

사용자1은 GET요청을 반복적으로 하고 있고 리소스가 변경된 상태를 받는 상황이 생긴다. GET은 멱등해서 계속 같은 결과를 받와야하는데?
멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.
내가 똑같은 요청을 반복적으로 했을 때 똑같은 응답이 오는지가 중요하다.
```

# 캐시가능(Cacheable)

1. 응답 결과 리소스를 캐시해서 사용해도 되는가?

2. GET, HEAD, POST, PATCH 캐시가능

3. 실제로는 GET, HEAD 정도만 캐시로 사용

- 캐시를 할때 캐시 키가 필요하다. POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구형이 쉽지 않음.

## HTTP caching

웹 사이트와 애플리케이션의 성능은 이전에 가져온 리소스들을 재사용함으로써 현저하게 향상될 수 있다. HTTP 캐싱을 활용하면 웹 사이트가 좀 더 빠르게 반응하도록 만들 수 있다.

캐싱은 주어진 리소스의 복사본을 저장하고 있다가 요청 시에 그것을 제공하는 기술이다. 웹 캐시가 자신의 저장소 내에 요청된 리소스를 가지고 있다면, 요청을 가로채 원래의 서버로 부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다. 이것은 모든 클라이언트를 서비스할 필요가 없어지므로 서버의 부하를 완화하고, (캐시가 원래 서버에 비해서)클라이언트에 더 가까이 있으므로 성능이 향상된다.(리소스를 회신하는데 더 적은 시간이 들게 된다.)주의할 점은 모든 리소스가 영원히 변하지 않는 것은 아니므로 리소스가 변하기 전까지만 캐싱하고 변한 이후에는 더이상 캐싱하지 않아야한다.

캐시에는 몇가지 종류가 있다. 크게 사설(private), 공유(shared)캐시 두 가지 부류로 분류 될 수 있다. 공유캐시는 한 명 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시다. 사설캐시는 한 명의 사용자만 사용하는 캐시다. 그 외에도 더 나은 신뢰도, 성능, 웹 사이트와 웹 애플리케이션의 확장(scaling)을 위해 웹 서버 위에 배포되는 게이트웨이 캐시, CDN, 리버스 프록시 캐시 그리고 로드 밸런서 등이 있다.

### 사설 브라우저 캐시

사설 캐시는 단일 사용자가 전용으로 사용한다. 브라우저 캐시는 그 사용자에 의하여 HTTP를 통해 다운로드된 모든 문서들을 가지고 있다. 이 캐시는 서버에 대한 추가적인 요청 없이 뒤로 가기나 앞으로 가기, 저장, 소스로 보기 등을 위해 방문했던 문서들을 사용할 수 있도록 해준다. 또한 유사한 방법으로 캐시된 컨텐츠의 오프라인 브라우징을 개선시킨다.
오프라인 브라우징? -> 예를 들어 크롬에서 방문한 페이지 자체를 캐싱해두면 인터넷이 연결되지 않은 상태여도 캐싱된 페이지를 방문 할 수 있다.

### 공유 프록시 캐시

공유 캐시는 한명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시다. 예를 들어 많은 사용자들이 조회하는 리소스의 경우 프록시서버에 해당 리소스를 캐싱해두고 사용자들이 그 리소스를 조회할 때는 프록시 서버에서 응답을 받게 할 수 있다.

### 캐싱 동작의 대상

HTTP캐싱은 선택적이지만 캐시된 리소스를 재사용하는 것은 보통 바람직하다. HTTP캐시들은 일반적으로 GET에 대한 응답만 캐싱한다(또한 HEAD). 캐싱을 위해서 캐시 키가 필요한데 기본 캐시 키(primary cache key)는 요청 메서드 그리고 대상 URI로 구성된다.(GET 요청만을 대상으로 하므로 URI만 사용되는 경우가 많다.)

- 검색 요청의 성공적인 결과: HTML 문서, 이미지 혹은 파일과 같은 리소스를 포함하는 GET 요청에 대한 200(OK) 응답.
- 영구적인 리다이렉트: 301 응답
- 오류 응답: 404 결과 페이지
- 완전하지 않은 결과: 206 응답
- 캐시 키로 사용하기에 적절한 무언가가 정의된 경위의 GET이외의 응답.
